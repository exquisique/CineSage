from fastmcp import FastMCP, Context
from dotenv import load_dotenv
import os
import sys
import re

# Load environment variables FIRST
load_dotenv()

# Add the current directory to sys.path to allow imports when running directly
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

import db
import tmdb
import gcal
import vector_db
from datetime import datetime

# Initialize DB
db.init_db()

# Initialize the MCP Server
mcp = FastMCP("Entertainment Concierge")

# --- Resources ---

@mcp.resource("entertainment://watchlist")
def get_watchlist() -> str:
    """Returns the current user watchlist."""
    items = db.get_watchlist_items()
    if not items:
        return "Watchlist is empty."
    
    # Format as a readable list
    return "\n".join([f"- {item['title']} ({item['media_type']})" for item in items])

@mcp.resource("entertainment://profile")
def get_taste_profile() -> str:
    """Returns the user's generated taste profile based on watched history."""
    reviews = db.get_user_reviews()
    if not reviews:
        return "No history yet. Watch some movies to build a profile!"
        
    # TODO: In the future, this will be generated by an LLM analyzing the reviews
    recent_favs = [r['title'] for r in reviews if r['rating'] and r['rating'] >= 8]
    return f"User has watched {len(reviews)} titles. Favorites: {', '.join(recent_favs)}"

# --- Tools ---

@mcp.tool()
def add_to_watchlist(title: str, media_type: str = "movie") -> str:
    """
    Adds a movie or TV show to the watchlist.
    
    Args:
        title: The title of the content.
        media_type: 'movie' or 'tv'.
    """
    return db.add_to_watchlist(title, media_type)

@mcp.tool()
def recommend_content(query: str = "", mood: str = "neutral", duration_minutes: int = 180, min_rating: float = 0.0) -> str:
    """
    Recommends movies or series based on a semantic query, mood, and available time.
    
    Args:
        query: A specific search query (e.g., "Batman" or "Something like Inception").
        mood: The desired vibe (e.g., "chill", "intense", "educational", "scifi").
        duration_minutes: Maximum duration available for watching.
        min_rating: Optional minimum rating (0-10) to filter results.
    """
    results = []
    header = ""
    
    try:
        # 1. Explicit "Like X" check (Highest Priority)
        # This ensures if you ask for "Like Vampire Diaries", we find that specifically.
        if query:
            like_match = re.search(r"(?:like|similar to)\s+(.+)", query, re.IGNORECASE)
            if like_match:
                target_movie = like_match.group(1).strip()
                
                # Search for the target movie
                search_res = tmdb.search_content(target_movie)
                if search_res:
                    target_id = search_res[0]['id']
                    target_title = search_res[0].get('title', target_movie)
                    results = tmdb.get_recommendations(target_id)
                    header = f"Since you asked for movies like **{target_title}**:"

        # 2. Personalization Check (Only if explicitly requested)
        # Only check logs if user asks "based on my taste", "for me", etc.
        personal_keywords = ["my taste", "my history", "my logs", "based on watched", "for me", "recommend something"]
        use_history = any(k in query.lower() for k in personal_keywords)
        
        if not results and query and use_history:
            try:
                # Check if this query relates to something we've already watched and liked
                similar_watched = vector_db.search_similar_content(query, n_results=1)
                
                if similar_watched:
                    match = similar_watched[0]
                    tmdb_results = tmdb.search_content(match['title'])
                    
                    if tmdb_results:
                        tmdb_id = tmdb_results[0]['id']
                        results = tmdb.get_recommendations(tmdb_id)
                        header = f"Based on your history (you liked **{match['title']}**):"
            except Exception as v_err:
                # print(f"Vector DB Search failed (ignoring): {v_err}")
                pass
        
        # 3. Standard Search (Direct query)
        if not results and query:
            results = tmdb.search_content(query)
            header = f"Search results for '{query}':"

        # 4. Mood/Discovery (No query)
        if not results and not query:
            results = tmdb.discover_by_mood(mood, min_rating)
            header = f"Recommendations for '{mood}' mood (Rating > {min_rating}):"

        # 5. Fallback
        if not results:
            results = tmdb.get_trending()
            header = f"No specific matches found for '{query or mood}'. Here are this week's trending titles:"

        if not results:
            return "No content found, even in trending. Check API key."

        # Filter and Format
        formatted_results = []
        count = 0
        for item in results:
            if count >= 10: break # Limit to top 10
            formatted_results.append(tmdb.format_result(item))
            count += 1
            
        return f"{header}\n\n" + "\n".join(formatted_results)

    except Exception as e:
        import traceback
        trace = traceback.format_exc()
        # print(f"DEBUG: Error in recommend_content: {trace}")
        return f"Error fetching recommendations: {repr(e)}\n\nDetails:\n{trace}"

@mcp.tool()
def log_watched(title: str, review_text: str = "", rating: int = None) -> str:
    """
    Logs a movie/series as watched, adds a review, and updates the taste profile.
    
    Args:
        title: The exact title of the content.
        review_text: Your personal thoughts on the content.
        rating: Optional score from 1-10.
    """
    # 1. Log to SQLite
    log_msg = db.log_review(title, review_text, rating)
    
    # 2. Update Vector Memory (Taste Twin)
    try:
        # Fetch details to get overview/genres for embedding
        results = tmdb.search_content(title)
        if results:
            item = results[0]
            overview = item.get("overview", "")
            # Genres are IDs in search results, would need mapping, but overview is most important for plot
            vector_msg = vector_db.add_movie_to_memory(title, overview, rating, [])
            return f"{log_msg}\n{vector_msg}"
    except Exception as e:
        return f"{log_msg}\n(Warning: Could not update vector memory: {str(e)})"
        
    return log_msg

@mcp.tool()
def schedule_viewing(title: str, datetime_preference: str = "tomorrow evening") -> str:
    """
    Schedules a viewing in the user's calendar.
    
    Args:
        title: The content to watch.
        datetime_preference: Natural language preference (e.g., "next Friday evening").
                             If not specific, it tries to find the next available evening slot.
    """
    try:
        start_time = gcal.find_next_available_slot()
        link = gcal.create_movie_event(title, start_time)
        return f"Successfully scheduled '{title}' for {start_time.strftime('%A, %B %d at %I:%M %p')}. Link: {link}"
    except Exception as e:
        return f"Error scheduling event: {str(e)}. (Did you add credentials.json?)"

@mcp.tool()
def find_streaming_source(title: str) -> str:
    """
    Finds where a movie/series is currently streaming.
    """
    try:
        # 1. Search for the content
        results = tmdb.search_content(title)
        if not results:
            return f"Could not find content named '{title}'."
        
        item = results[0]
        tmdb_id = item['id']
        media_type = item['media_type'] # 'movie' or 'tv'
        real_title = item.get('title') or item.get('name')
        
        # 2. Get providers
        providers = tmdb.get_watch_providers(media_type, tmdb_id)
        
        if not providers:
            return f"'{real_title}' is not currently streaming on any flat-rate subscription services in India (or data is unavailable)."
            
        return f"'{real_title}' is available on: {', '.join(providers)}."
        
    except Exception as e:
        return f"Error finding streaming source: {str(e)}"

if __name__ == "__main__":
    mcp.run()
